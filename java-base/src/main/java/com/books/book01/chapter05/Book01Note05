第5章 继 承
▲ 类、超类和子类 
▲ Object：所有类的超类 
▲ 泛型数组列表 
▲ 对象包装器和自动打包 
▲ 参数数量可变的方法
▲ 枚举类
▲ 反射
▲ 继承设计的技巧
▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄

5.1 类、超类和子类
从理论上讲，在Manager与 Employee之间存在着明显的“ is-a”（是）关系，每个
经理都是一名雇员： “ is-a”关系是继承的一个明显特征。下面是由继承Employee类
来定义Manager类的格式，关键字extends表示继承。
class Manager extends Employee {
	……
}
注意：子类中的方法并不能直接访问超类的私有域，而要调用setter、getter方法
	如果子类覆写了超类中的方法，那么调用超类方法的时候就要使用super关键字
注释：有些人认为super与this引用是类似的概念，实际上，这样比较并不太恰当。这是因
为super不是一个对象的引用，不能将super赋给另一个对象变量，它只是一个指示编译器
调用超类方法的特有关键字。
demo: ManagerTest.java

5.1.1 继承层次
HZ: 可以同时继承多个超类
	可以有多层继承

5.1.2 多态
在Java程序设计语言中，对象变量是多态的。一个Employee变量既可以引用一个Employee
类对象，也可以引用一个Employee类的任何一个子类的对象（例如， Manager、 Executive
等等）。
警告：在Java中，子类数组的引用可以转换成超类数组的引用，而不需要采用强制类型转换。

5.1.3 动态绑定（HZ:重载？）
注释：前面曾经说过，方法的名字和参数列表称为方法的签名。例如， f(int)和f(String)
是两个具有相同名字，不同签名的方法。如果在子类中定义了一个与超类签名相同的方法，那么子
类中的这个方法就覆盖了超类中的这个相同签名的方法。不过，返回类型不是签名的一部分，因此，
在覆盖方法时，一定要保证返回类型的兼容性。在Java SE 5.0以前的版本中，要求返回类型
必须是一样的。现在允许子类将覆盖方法的返回类型定义为原返回类型的子类型。
警告：在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。特别是，如果超类方法是
public，子类方法一定要声明为public。经常会发生这类错误：在声明子类方法的时候，遗
漏了 public修饰符。此时，编译器将会把它解释为试图降低访问权限。

5.1.4 阻止继承： final类和方法
类中的方法也可以被声明为final。如果这样做，子类就不能覆盖这个方法（ final类中的所
有方法自动地成为final方法）。

5.1.5 强制类型转换
对象引用的转换语法与数值表达式的类型转换类似，仅需要用一对圆括号将目标类名括起来，并放
置在需要转换的对象引用之前就可以了。
在一般情况下，应该尽量少用类型转换和instanceof运算符。

5.1.6 抽象类
抽象方法充当着占位的角色，它们的具体实现在子类中。扩展抽象类可以有两种选择。一种是在子
类中定义部分抽象方法或抽象方法也不定义，这样就必须将子类也标记为抽象类；另一种是定义全
部的抽象方法，这样一来，子类就不是抽象的了。
demo：PersonTest.java

5.1.7 受保护访问
下面归纳一下Java用于控制可见性的4个访问修饰符：
1）仅对本类可见—private。
2）对所有类可见—public。
3）对本包和所有子类可见—protected。
4）对本包可见—默认，所谓默认是指没有标明任何修饰符的情况，这是一种不太受欢迎
的形式。

5.2 Object：所有类的超类
所有的类都默认继承自Object
5.2.1 Equals方法

5.2.2 相等测试与继承
Java语言规范要求equals方法具有下面的特性：
1） 自反性：对于任何非空引用 x， x.equals(x) 应该返回 true。
2） 对称性：对于任何引用 x和y，当且仅当y.equals(x)返回true， x.equals(y)
也应该返回true。
3） 传递性：对于任何引用 x、 y和 z，如果 x.equals(y)返回 true， y.equals(z)
返回 true，x.equals(z) 也应该返回 true。
4） 一致性：如果x和y引用的对象没有发生变化，反复调用 x.equals(y) 应该返回同样
的结果。
5）对于任意非空引用 x， x.equals(null) 应该返回 false。
这些规则十分合乎情理，从而避免了类库实现者在数据结构中定位一个元素时还要考虑调用
 x.equals(y)，还是调用 y.equals(x)的问题。
注意：使用instanceof不能解决超类和子类的问题

5.2.3 HashCode方法
散列码（ hash code）是由对象导出的一个整型值。散列码是没有规律的。如果x和y是两个
不同的对象， x.hashCode( )与 y.hashCode( )基本上不会相同。在表5-1 中列
出了几个通过调用String类的hashCode方法得到的散列码。
String类使用下列算法计算散列码：
int hash = 0;
for(int i=0;i<length();i++){
	hash = 31 * hash + charAt(i);
}
由于hashCode方法定义在Object类中，因此每个对象都有一个默认的散列码，其值为对象
的存储地址。看一下下面这个例子。
demo: HashCodeDemo.java 中的 stringHashCode()方法
请注意，字符串 s与t拥有相同的散列码，这是因为字符串的散列码是由内容导出的。而字符串
缓冲sb与tb却有着不同的散列码，这是因为在StringBuffer类中没有定义hashCode
方法，它的散列码是由 Object类的默认hashCode方法导出的对象存储地址。
demo: HashCodeDemo.java -> (function) stringBuilderHashCode()

如果重新定义equals方法，就必须重新定义hashCode方法，以便用户可以将对象插入到散
列表中（有关散列表的内容将在卷II的第2章中讨论）。
HashCode方法应该返回一个整型数值（也可以是负数），并合理地组合实例域的散列码，以
便能够让各个不同的对象产生的散列码更加均匀。
例如，下面是Employee类的hashCode方法。
demo: EqualsTest.java -> (class) Employee -> (function) hashCode()

Equals与hashCode的定义必须一致：如果x.equals(y)返回 true，那么 
x.hashCode()就必须与y.hashCode( )具有相同的值。例如，如果用定义的 
Employee.equals比较雇员的 ID，那么hashCode方法就需要散列ID，而不是
雇员的姓名或存储地址。 

提示：如果存在数组类型的域，那么可以使用静态的Arrays.hashCode方法计算一个散列
码，这个散列码由数组元素的散列码组成。

5.2.4 ToString方法
在Object中还有一个重要的方法，就是toString方法，它用于返回表示对象值的字符串。

提示：强烈建议为自定义的每一个类增加toString方法。这样做不仅自己受益，而且所有
使用这个类的程序员也会受益匪浅。
HZ: 当前并没有体会到增加toString()的好处所在，摊手~

警告：令人烦恼的是，数组继承了 object类的 toString方法，数组类型将按照旧的格式打
印。要想打印多维数组（即，数组的数组）则需要调用 Arrays.deepToString方法。
demo: ToStringTest.java

5.3 泛型数组列表
ArrayList是一个采用类型参数（ type parameter）的泛型类（ generic 
class）。
为了指定数组列表保存的元素对象类型，需要用一对尖括号将类名括起来加在后面，例如，
ArrayList <Employee>。在第13章中将可以看到如何自定义一个泛型类，这里并
不需要了解任何技术细节就可以使用 ArrayList类型。
数组列表管理着对象引用的一个内部数组。最终，数组的全部空间有可能被用尽。这就显现出
数组列表的操作魅力：如果调用 add且内部数组已经满了，数组列表就将自动地创建一个更
大的数组，并将所有的对象从较小的数组中拷贝到较大的数组中。

trimToSize()：将数组列表的存储容量削减到当前尺寸。

5.3.1 访问数组列表元素
很遗憾，天下没有免费的午餐。数组列表自动扩展容量的便利增加了访问元素语法的复杂程度。
其原因是ArrayList类并不是Java程序设计语言的一部分；它只是一个由某些人编写且被
放在标准库中的一个实用类。
使用 get和set方法实现访问或改变数组元素的操作，而不使用人们喜爱的 [] 语法格式。
例如，要设置第i个元素，可以使用：
staff.set(i,harry);
它等价于对数组a的元素赋值（数组的下标从0开始）：
a[i] = harry;
demo: ArrayListTest.java
HZ：数组和数组列表的区别：
数组列表只能使用set，get，add方法进行操作，add方法如果指定为位置n，那么n后面
的元素就一次向后递推一个位置。
数组可以直接使用[]进行操作

5.3.2 类型化与原始数组列表的兼容性
可以将一个类型化的数组列表传递给update方法，而并不需要进行任何类型转换
HZ：就是SE5.0之前声明数组里列表的时候可以不指定数据类型，这种数组列表的兼容问题

5.4 对象包装器与自动打包
Java SE 5.0的另一个改进之处是更加便于添加或获得数组元素。下面这个调用
	list.add(3); 
将自动地变换成 
	list.add(new Integer(3));
这种变换被称为自动打包（ autoboxing）。

相反地，当将一个Integer对象赋给一个int值时，将会自动地拆包。也就是说，编译器将下
列语句：
	int n = list.get(i);
翻译成：
	int n = list.get(i).intValue();
甚至在算术表达式中也能够自动地打包和拆包。例如，可以将自增操作符应用于一个包装器
引用：
	Integer n = 3;
	n++;
编译器将自动地插入一条拆开对象包的指令，然后进行自增计算，最后再将结果打入对象包内。
在很多情况下，容易有一种假象，即基本类型与它们的对象包装器是一样的，只是它们的
相等性不同。大家知道， ==运算符也可以应用于对象包装器对象，只不过检测的是对象是否指
向同一个存储区域，因此，下面的比较通常不会成立：
	Integer a = 1000;
	Integer b = 1000;
	if(a == b)
		……
然而， Java实现却有可能（ may）让它成立。如果将经常出现的值包装到同一个对象中，
这种比较就有可能成立。这种不确定的结果并不是我们所希望的。解决这个问题的办法是在两
个包装器对象比较时调用 equals方法。
最后强调一下，打包和拆包是编译器认可的，而不是虚拟机。编译器在生成类的字节码时，
插入必要的方法调用。虚拟机只是执行这些字节码。

5.5 参数数量可变的方法
比如main方法

5.6 枚举类
在比较两个枚举类型的值时，永远不需要调用 equals，而直接使用“ = =”就可以了。
如果需要的话，可以在枚举类型中添加一些构造器、方法和域。当然，构造器只是在构造
枚举常量的时候被调用。下面是一个示例：
demo: EnumTest.java

5.7 反射
反射库（ reflection library）提供了一个非常丰富且精心设计的工具集，以便编写
能够动态操纵Java代码的程序。这项功能被大量地应用于JavaBeans中，它是Java组件
的体系结构（有关JavaBeans的详细内容在卷II中阐述）。使用反射， Java可以支持
Visual Basic用户习惯使用的工具。特别是在设计或运行中添加新类时，能够快速地应用
开发工具动态地查询新添加类的能力。
能够分析类能力的程序被称为反射（ reflective）。反射机制的功能极其强大。在下面的
章节中可以看到，可以用‘反射机制：
• 在运行中分析类的能力。
• 在运行中查看对象，例如，编写一个toString方法供所有类使用。
• 实现数组的操作代码。
• 利用 Method对象，这个对象很像C++中的函数指针。
反射是一种功能强大且复杂的机制。使用它的主要对象是工具构造者，而不是应用程序员。
如果仅对设计应用程序感兴趣，而对构造工具不感兴趣，可以跳过本章的剩余部分，稍后再返
回来学习。

5.7.1 Class类
在程序运行期间， Java运行时系统始终为所有的对象维护一个被称为运行时的类型标识。
这个信息保存着每个对象所属的类足迹。虚拟机利用运行时信息选择相应的方法执行。
然而，可以通过专门的Java类访问这些信息。保存这些信息的类被称为Class，这个名字
很容易让人混淆。 Object类中的getClass( )方法将会返回一个Class类型的实例。

5.7.2 捕获异常
try{}catch(){}finally{}

5.7.3 利用反射分析类的能力
在java.lang.reflect包中有三个类Field、 Method和Constructor分别用
于描述类的域、方法和构造器。
demo: ReflectionTest.java

5.7.4 在运行时使用反射分析对象
demo: ObjectAnalyzerTest.java

5.7.5 使用反射编写泛型数组代码
demo: ArrayGrowTest.java

5.7.6 方法指针
demo: MethodPointerTest.java








































































