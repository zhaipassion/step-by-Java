第4章 对 象 与 类
主要内容：
▲ 面向对象程序设计概述 
▲ 使用现有类 
▲ 用户自定义类 
▲ 静态域和方法 
▲ 方法参数 
▲ 对象构造
▲ 包
▲ 类路径
▲ 文档注释
▲ 类设计技巧

▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄

4.1 面向对象程序设计概述
4.1.1 类
类（ class）是构造对象的模板或蓝图。
由类构造（ construst）对象的过程称为创建类的实例（ instance）。
封装（ encapsulation，有时称为数据隐藏）是与对象有关的一个重要概念。
实现封装的关键在于绝对不能让类中的方法直接地访问其他类的实例域。程序仅通过对象
的方法与对象数据进行交互。封装给予对象了“黑盒”特征，这是提高重用性和可靠性的关键。
这意味着一个类可以全面地改变存储数据的方式，只要仍旧使用同样的方法操作数据，其他对
象就不会知道或介意所发生的变化。
OOP的另一个原则会让用户自定义Java类变得轻而易举，这就是：类可以通过扩展另一个
类来建立。事实上，在Java中，所有的类都源自于一个“神通广大的超类”，它就是 Object。

4.1.2 对象
要想使用 OOP，一定要清楚对象的三个主要特性：
• 对象的行为（ behavior） —可以对对象施加哪些操作，或可以对对象施加哪些方法？
• 对象的状态（ state） —当施加那些方法时，对象如何响应？
• 对象标识（ identity） —如何辨别具有相同行为与状态的不同对象？
同一个类的所有对象实例，由于支持相同的行为而具有家族相似性。对象的行为是用可调
用的方法定义的。
此外，每个对象都保存着描述当前特征的信息。这就是对象的状态。对象的状态可能会随
着时间而发生改变，但这种改变不会是自发的。对象状态的改变必须通过调用方法实现（如果
不经过方法调用就可以改变对象状态，只能说明封装性遭到了破坏）。

4.1.3 识别类
传统的过程化程序设计，必须从顶部的main函数开始编写程序。在设计面向对象的系统时
没有所谓的“顶部”。对于学习 OOP的初学者来说常常会感觉无从下手。答案是：首先从设计
类开始，然后再往每个类中添加方法。

4.1.4 类之间的关系
在类之间，最常见的关系有
• 依赖（“ uses-a”）
• 聚合（“ has-a”）
• 继承（“ is-a”）
参考：【表4-1 表达类关系的UML符号.jpg】

4.2 使用现有类
4.2.1 对象与对象变量
要想使用对象，就必须首先构造对象，并指定其初始状态。然后，对对象施加方法。
在对象与对象变量之间存在着一个重要的区别。例如，语句
	Date birthday = new Date();
中：new Date()是一个对象，birthday只是一个变量。再如，语句：
	Date deadline;               // deadline没有引用任何对象
定义了一个对象变量deadline，它可以引用Date类型的对象。但是，一定要认识到：变
量deadline不是一个对象，实际上也没有引用对象。此时，不能将任何Date方法应用在
这个变量上。如果要使用变量deadline，有两种方法：
用新构造的对象初始化这个变量，或者让这个变量引用一个已存在的对象：
	deadline = new Date();
	deadline = birthday;

4.2.2 Java类库中的GregorianCalendar类
Date类的实例有一个状态，即特定的时间点。
尽管在使用 Date类时不必知道这一点，但时间是用距离一个固定时间点的毫秒数（可正可
负）表示的，这个点就是所谓的纪元（ epoch），它是UTC时间 1970年1月 1日 00:00:00。 
但是，同一时间点采用中国的农历表示和采用希伯来的阴历表示就太不一样，对于火星历来
说就更不可想像了。类库设计者决定将保存时间与给时间点命名分开。所以标准Java类库
分别包含了两个类：一个是用来表示时间点的Date类；另一个是用来表示大家熟悉的日历
表示法的GregorianCalendar类。事实上， GregorianCalendar类扩展了
一个更加通用的Calendar类，这个类描述了日历的一般属性。理论上，可以通过扩展
Calendar类来实现中国的阴历或者是火星日历。然而，标准类库中只实现了 Gregorian
日历。
将时间与日历分开是一种很好的面向对象设计。通常，最好使用不同的类表示不同的概念。
Date类只提供了少量的方法用来比较两个时间点。例如 before 和 after 方法分别
表示一个时间点是否早于另一个时间点，或者晚于另一个时间点。
注释：实际上， Date类还有getDay、 getMonth以及getYear等方法，然而并不
推荐使用这些方法。当类库设计者意识到某个方法不应该存在时，就把它标记为不鼓励使用。
当类库的设计者意识到单独设计日历类更有实际意义时，这些方法已经是Date类的一部
分。引入日历类之后， Date类中的这些方法被标明为不鼓励使用，虽然在程序中仍然可
以使用它们，但是如果这样做，编译时会出现警告。最好还是不要使用这部分方法，它
们有可能会从未来的类库版本中删去。

4.2.3 更改器方法与访问器方法
更改器方法可以更改对象的值，比如set方法
访问器方法只读取不更改对象的值，比如get方法
demo: CalendarTest.java

4.3 用户自定义类

4.3.1 一个Employee类
demo: EmployeeTest.java

4.3.2 多个源文件的使用
在上例中，一个源文件包含了两个类。许多程序员习惯于将每一个类存在一个单独的源文件
中。例如，将 Employee类存放在文件Employee.java中，将 EmployeeTest
类存放在文件EmployeeTest.java中。

4.3.3 解析Employee类
4种访问级别：public，protected，default，private
本例中使用的public修饰符

4.3.4 从构造器开始
本章稍后，还会更加详细地介绍有关构造器的内容。现在只需要记住：
• 构造器与类同名
• 每个类可以有一个以上的构造器
• 构造器可以有0个、 1个或1个以上的参数
• 构造器没有返回值
• 构造器总是伴随着new操作一起调用

4.3.5 隐式参数与显式参数
方法用于操作对象以及存取它们的实例域。例如，方法：
public void raiseSalary(double byPercent) {
	double raise = salary * byPercent / 100;
	salary += raise;
}
raiseSalary方法有两个参数。第一个参数被称为隐式（ implicit）参数，是出现在方法名前的
Employee类对象。第二个参数位于方法名后面括号中的数值，这是一个显式（ explicit）参数。
在每一个方法中，关键字 t h i s 表示隐式参数。如果需要的话，可以用下列方式编写raiseSalary
方法：
public void raiseSalary(double byPercent) {
	double raise = this.salary * byPercent / 100;
	this.salary += raise;
}

4.3.6 封装的优点

4.3.7 基于类的访问权限

4.3.8 私有方法

4.3.9 ★★★★★ Final实例域 ★★★★★ 
可以将实例域定义为final。构建对象时必须初始化这样的域。也就是说，必须确保在每一
个构造器执行之后，这个域的值被设置，并且在后面的操作中，不能够再对它进行修改。例如，
可以将Employee类中的name域声明为final，因为在对象构建之后，这个值不会再被
修改，即没有setName方法。
class Employee {
	……
	private final String name;
}
final修饰符大都应用于基本数据（ primitive）类型域，或不可变（ immutable）类
的域（如果类中的每个方法都不会改变其对象，这种类就是不可变的类。例如， String类就是
一个不可变的类）。对于可变的类，使用 final修饰符可能会对读者造成混乱。例如，
	private final Date hiredate;
仅仅意味着存储在 hiredate变量中的对象引用在对象构造之后不能被改变，而并不意味着
hiredate 对象是一个常量。任何方法都可以对hiredate引用的对象调用 setTime更改器。
demo: FinalModifier.java

4.4 静态域与静态方法
4.4.1 静态域
如果将域定义为static，每个类中只有一个这样的域。而每一个对象对于所有的实例域却都
有自己的一份拷贝。例如，假定需要给每一个雇员赋予惟一的标识码。这里给Employee类添加
一个实例域id和一个静态域nextId：
class Employee {
	……
	private int id;
	private static int nextId = 1;
}
现在，每一个雇员对象都有一个自己的 id域，但这个类的所有实例将共享一个nextId域。
换句话说，如果有1000个Employee类的对象，则有1000个实例域id。但是，只有一个静态域
nextId。即使没有一个雇员对象，静态域nextId也存在。它属于类，而不属于任何独立的对象。
注释：在绝大多数的面向对象程序设计语言中，静态域被称为类域。术语“ static”只是
沿用了 C++的叫法，并无实际意义。
下面实现一个简单的方法（这个范例让我理解了final和static的区别）：
public void setId(){
	id = nextId;
	nextId++;
}
假定为harry设定雇员标识码：
harry.setId();
harry的id域被设置为静态域nextId当前的值，并且静态域nextId的值加1：
harry.id = Employee.nextId;
Employee.nextId++;

HZ: 区分final修饰符和static修饰符的区别：
	final保持不变
	static可以共享

4.4.2 静态常量
静态变量使用得比较少，但静态常量却使用得比较多。例如，在Math类中定义了一个静态
常量：
public class Math {
	……
	public static final double PI = 3.14159265358979323846;
	……
}
在程序中，可以采用 Math.PI的形式获得这个常量。
如果关键字static被省略， PI就变成了 Math类的一个实例域。需要通过Math类的对象
访问 PI，并且每一个Math对象都有它自己的一份PI拷贝。

4.4.3 静态方法
静态方法是一种不能向对象实施操作的方法。例如， Math类的pow方法就是一个静态方法。
表达式: Math.pow(x, a) 计算幂x^a。在运算时，不适用任何Math队形。换句话
说，没有隐式的参数。可以认为静态方法是没有this参数的方法（在一个非静态的方法中， 
this参数表示这个方法的隐式参数）。
因为静态方法不能操作对象，所以不能在静态方法中访问实例域。但是，静态方法可以访问自
身类中的静态域。下面是使用这种静态方法的一个示例：
public static int getNextId(){
	return nextId;      // returns static field
}
可以通过类名调用这个方法：
int n = Employee.getNextId();

HZ: 静态域（静态变量）（类域）：使用static修饰类中的变量
	静态常量：使用static final 修饰类中的常量
	静态方法：static修饰的方法，没有this这个隐式参数
	所以，static 和 final 是完全不同的概念，但可以组合使用

4.4.4 Factory方法
demo: FactoryTest.java
为什么 NumberFormat类不利用构造器完成这些操作呢？这主要有两个原因：
• 无法命名构造器。构造器的名字必须与类名相同。但是，这里希望将得到的货币实例和
百分比实例采用不用的名字。
• 当使用构造器时，无法改变所构造的对象类型。而Factory方法将返回一个
DecimalFormat类对象，这是NumberFormat的子类（有关继承的详细内容请参
看第5章）。


4.4.5 Main方法
demo: StaticTest.java

4.5 方法参数
值调用（ call by value）表示方法接收的是调用者提供的值。而引用调用（ call
by reference）表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用
所对应的变量值，而不能修改传递值调用所对应的变量值。 
下面总结一下在Java程序设计语言中，方法参数的使用情况：
• 一个方法不能修改一个基本数据类型的参数（即数值型和布尔型）。
• 一个方法可以改变一个对象参数的状态。
• 一个方法不能实现让对象参数引用一个新的对象。
demo: ParamTest.java
在这个程序中，首先试图将一个值参数的值提高两倍，但没有成功;随后，成功地将一个雇员
的薪金提高了两倍。方法结束之后， harry引用的对象状态发生了改变。这是因为这个方法
可以通过对象引用的拷贝修改所引用的对象状态。最后，程序演示了 swap方法的失败效果。

4.6 对象构造
4.6.1 重载
如果多个方法（比如， GregorianCalendar构造器方法）有相同的名字、不同的参数，
便产生了重载。编译器必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特
定方法调用所使用的值类型进行匹配来挑选出相应的方法。

4.6.2 默认域初始化
如果在构造器中没有显式地给域赋予初值，那么就会被自动地赋为默认值：数值为0、布尔值
为flase、对象引用为null。然而，只有缺少程序设计经验的人才会这样做。确实，如果
不明确地对域进行初始化，就会影响程序代码的可读性。

4.6.3 默认构造器
如果在编写一个类时没有编写构造器，那么系统就会提供一个默认构造器。这个默认构造器将
所有的实例域设置为默认值。于是，实例域中的数值型数据设置为0、布尔型数据设置为
false、所有对象变量将设置为null。

4.6.4 显式域初始化
由于类的构造器方法可以重载，所以可以采用多种形式设置类的实例域的初始状态。确保不
管怎样调用构造器，每个实例域都可以被设置为一个有意义的初值。下面示范赋值的两种方法：

可以在类定义中，直接将一个值赋给任何域：
class Employee {
	……
	private String name = "";
}
初始值不一定是常量。在下面的例子中，可以调用方法对域进行初始化:
class Employee {
	……
	static int assignId() {
		int r = nextId;
		nextId++;
		return r;
	}
	……
	private int id = assignId();
}

4.6.5 参数名
参数变量用同样的名字将实例域屏蔽起来。例如，如果将参数命名为salary， salary
将引用这个参数，而不是实例域。但是，可以采用 this.salary的形式访问实例域。回
想一下， this指示隐式参数，也就是被构造的对象。下面是一个示例:
public Employee(String name, double salary) {
	this.name = name;
	this.salary = salary;
}

4.6.6 调用另一个构造器
使用this关键字调用另外一个构造方法

4.6.7 初始化块
前面已经讲过两种初始化数据域的方法：
• 在构造器中设置值
• 在声明中赋值
实际上， Java还有第三种机制，称为初始化块（ initialization block）。在
一个类的声明中，可以包含多个代码块。只要构造类的对象，这些块就会被执行。
demo：ConstructorTest.java

4.6.8 对象析构与finalize方法
可以为任何一个类添加finalize方法。 finalize方法将在垃圾回收器清除对象之前
调用。在实际应用中，不要依赖于使用 finalize方法回收任何短缺的资源，这是因为很
难知道这个方法什么时候才能够调用。

4.7 包

4.7.1 类的导入
第一种方式是在每个类名之前添加完整的包名。例如：
java.util.Date today = new java.util.Date();
更简单且更常用的方式是使用 import语句。 import语句是一种引用包含在包中的类的
简明描述。一旦使用了 import语句，在使用类时，就不必写出包的全名了。
Date today = new Date();
但在发生命名冲突的时候，就不能不注意包的名字了。例如， java.util和java.sql
包都有日期（ Date）类。如果这两个Date类都需要使用，该怎么办呢？答案是，在每个类
名的前面加上完整的包名。

4.7.2 静态导入
从Java SE 5.0开始， import语句不仅可以导入类，还增加了导入静态方法和静态域
的功能。
如果对Math类使用静态导入，就可以采用更加自然的方式使用算术函数。例如，
	sqrt(pow(x, 2) + pow(y, 2));
代替
	Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
如果需要使用大量带有冗长名字的常量，就应该使用静态导入。
	if(d.get(DAY_OF_WEEK)==MONDAY)
代替
	if(d.get(Calendar.DAY_OF_WEEK)==Calendar.MONDAY)

4.7.3 将类放入包中
package
demo: PackageTest.java

4.7.4 包作用域
标记为public的部分可以被任意的类使用；标记为private 的部分只能被定义它们
的类使用。如果没有指定public或private，这个部分（类、方法或变量）可以被同
一个包中的所有方法访问。

4.8 类路径

4.9 文档注释

4.10 类设计技巧
































